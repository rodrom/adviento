# 09 - Rope Bridge

Where **not** to step.

Consider a rope with a know at each end; these knots mark the **head** and
the **tail** of the rope.

If the *head* moves far enough away from the tail, the tail is pulled
toward the *head*.

*Si la cabeza se mueve lo suficientemente lejos de la cola, la cola es
arrastrada hacia la cabeza.*

According to [Plank lengths](https://en.wikipedia.org/wiki/Planck_units#Planck_length),
you should be able to model the positions of the knots on a two-dimensional grid. Then by following a hypothetical series of motions (input), for the head, you can determine how the tail will move.

Due to the aforementioned Planck lengths, the rope must be quite short;
in fact, the head (`H`) and tail (`T`) must *always be touching* (diagonally adjacent and even overlapping both count as touching).

```
....
.TH.
....

....
.H..
..T.
....

...
.H. (H covers T)
...

```

If the head is ever two steps directly up, down, left, or right from the tail, the tail must also move one step in that direction:
```text
.....    .....    .....
.TH.. -> .T.H. -> ..TH.
.....    .....    .....

...    ...    ...
.T.    .T.    ...
.H. -> ... -> .T.
...    .H.    .H.
...    ...    ...
```

Otherwise, if the head and tail aren't touching and aren't in the same row or colum, the tail always move one step diagonally to keep up:

```text
.....    .....    .....
.....    ..H..    ..H..
..H.. -> ..... -> ..T..
.T...    .T...    .....
.....    .....    .....

.....    .....    .....
.....    .....    .....
..H.. -> ...H. -> ..TH.
.T...    .T...    .....
.....    .....    .....
```

You just need to work out where the tail goes as the head follows a series of motions.

Assume the **head and the tail both start at the same position, overlapping**.

For example:
```text
R 4
U 4
L 3
D 1
R 4
D 1
L 5
R 2
```

The syntax of the move is `<direction> <numberOfSteps>`.
After each step, you'll need to update the position of the tail if the
step means the head is no longer adjacent to the tail.

```
== Initial State ==

......
......
......
......
H.....  (H covers T, s)

== R 4 ==

......
......
......
......
TH....  (T covers s)

......
......
......
......
sTH...

......
......
......
......
s.TH..

......
......
......
......
s..TH.

== U 4 ==

......
......
......
....H.
s..T..

......
......
....H.
....T.
s.....

......
....H.
....T.
......
s.....

....H.
....T.
......
......
s.....

== L 3 ==

...H..
....T.
......
......
s.....

..HT..
......
......
......
s.....

.HT...
......
......
......
s.....

== D 1 ==

..T...
.H....
......
......
s.....

== R 4 ==

..T...
..H...
......
......
s.....

..T...
...H..
......
......
s.....

......
...TH.
......
......
s.....

......
....TH
......
......
s.....

== D 1 ==

......
....T.
.....H
......
s.....

== L 5 ==

......
....T.
....H.
......
s.....

......
....T.
...H..
......
s.....

......
......
..HT..
......
s.....

......
......
.HT...
......
s.....

......
......
HT....
......
s.....

== R 2 ==

......
......
.H....  (H covers T)
......
s.....

......
......
.TH...
......
s.....
```

After simulating the rope, you can count all the positions the *tail*
visited at least once. In this diagram, `s` again marks the starting position (also visited) and # marks other positions the tail visited:

```test
..##..
...##.
.####.
....#.
s###..
```

### Solution

The first thing to do is create a this classes called `Rope`, `Bridge`, `Point`, and `Move` with these properties, and the enum `Direction`:
```php
class Rope
{
    private Point $head;
    private Point $tail;
    private int $size;
}

class Point
{
    private int $x,
    private int $y
}

class Move
{
    private Direction $direction,
    private int $steps
}

enum Direction: int
{
    case Up;
    case Right;
    case Down;
    case Left;
    // diagonals as well
}

class Bridge
{
    private Rope $rope;
    private Itinerary $itineraryOfTail;
}

class Itinerary
{
    private array $x;
    private array $y;
    private array $movesHistory;
}
```

The second step, is create the logic for *moving* the **rope** across the **bridge**. So we can create a method in `Bridge::moveRope(Move $move): Point` that receives a **move**, updates the points of the `rope->head` and `rope->tail`, as well as the **itinerary**. Returns the Rope.

### Move the rope

This function should update the position of the **head** changing the point according to the **move**. In this part of the problem, we don't need to consider what parts of the head visit the brige, but the tail, yes. And the tail moves according to the head. This are the cases:

- H and T in the same position advance in one direction. The tail will remain behind the H by the size of the rope (we will consider always a size of 1, in case of a bigger rope, could be that steps are note enough to move all the rope).

- H and T are in different positions, but the same x-coordinate or y-coordinate and the move keeps this coordinate in opposite direction of the tail, the logic is the same.

- Well imagine a ROPE and don't use to hang yourself. Just move it in and imagine what happen with it.

So firts, move the head: `Rope::moveHead`.
Second, move the tail, and if you are not a gecko in danger,
don't forget to do it, at the same time that your head, in case that the size is bigger than the steps.

However, this move is so complex, that maybe is better to test that everything works when the head and the tail is the same (size of the rope 0).

It could be useful, but not mandatory, to have some type of representation of the bridge and the elements of the problem.

